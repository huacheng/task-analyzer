---
description: "Task lifecycle management â€” init, plan, research, check, verify, exec, merge, report, auto, cancel, list, annotate, summarize"
arguments:
  - name: subcommand
    description: "Sub-command: init, plan, research, check, verify, exec, merge, report, auto, cancel, list, annotate, summarize"
    required: true
  - name: args
    description: "Sub-command arguments (varies by sub-command)"
    required: false
---

# /ai-cli-task â€” Task Lifecycle Management

Single entry point for task lifecycle management in the `AiTasks/` directory.

## Arguments

{{ARGUMENTS}}

## Shared Context

### AiTasks/ Directory Convention

```
AiTasks/
â”œâ”€â”€ .index.json                # Root index (task module listing, JSON array)
â”œâ”€â”€ .type-registry.md          # Auto-expanding type registry (seed + discovered types, shared across tasks)
â”œâ”€â”€ .experiences/              # Cross-task knowledge base (by type, distilled from completed tasks)
â”‚   â”œâ”€â”€ .summary.md            # Condensed index of all experience files (overwritten on each new entry)
â”‚   â”œâ”€â”€ software.md            # Lessons from completed software tasks
â”‚   â””â”€â”€ <type>.md              # One file per task type (append-only, compacted at 500 lines)
â”œâ”€â”€ .references/               # External reference materials (by topic, collected by research sub-command)
â”‚   â”œâ”€â”€ .summary.md            # Condensed index of all reference files (overwritten on each new entry)
â”‚   â””â”€â”€ <topic>.md             # One file per topic, kebab-case (e.g., express-middleware.md)
â””â”€â”€ <module-name>/             # One directory per task module
    â”œâ”€â”€ .index.json            # Task metadata (JSON) â€” machine-readable
    â”œâ”€â”€ .target.md             # Requirements / objectives (human-authored)
    â”œâ”€â”€ .type-profile.md       # Domain methodology profile (research-informed, written by plan, updated by all phases)
    â”œâ”€â”€ .analysis/             # Evaluation history (one file per assessment by check)
    â”‚   â””â”€â”€ .summary.md        # Condensed summary of all evaluations (overwritten on each new entry)
    â”œâ”€â”€ .test/                 # Test criteria & results (one file per phase, by plan/exec/check)
    â”‚   â””â”€â”€ .summary.md        # Condensed summary of all criteria & results (overwritten on each new entry)
    â”œâ”€â”€ .bugfix/               # Issue history (one file per mid-exec issue by check)
    â”‚   â””â”€â”€ .summary.md        # Condensed summary of all issues & fixes (overwritten on each new entry)
    â”œâ”€â”€ .notes/                # Research notes & experience log (*-plan/*-exec suffix per origin)
    â”‚   â””â”€â”€ .summary.md        # Condensed summary of all research & decisions (overwritten on each new entry)
    â”œâ”€â”€ .summary.md            # Condensed context summary (written by plan/check/exec, read by all)
    â”œâ”€â”€ .report.md             # Completion report (written by report)
    â”œâ”€â”€ .tmp-annotations.json  # Transient annotation transport (frontend â†’ annotate)
    â”œâ”€â”€ .auto-signal           # Transient auto-loop progress report (ephemeral)
    â”œâ”€â”€ .auto-stop             # Transient auto-loop stop request (ephemeral)
    â”œâ”€â”€ .plan.md               # Implementation plan (generated by plan, editable via Plan panel)
    â””â”€â”€ .plan-superseded.md    # Archived plan on re-plan (renamed from .plan.md, suffixed if multiple)
```

- **Dot-prefixed** files are system-managed; `.target.md` and `.plan.md` are human-editable via the Plan annotation panel
- `.plan.md` is the implementation plan file, generated by `plan --generate` and editable through the Plan panel
- `.tmp-annotations.json`, `.auto-signal`, and `.auto-stop` are ephemeral (should be in `.gitignore`)
- `.notes/` files use origin suffix: `<YYYY-MM-DD>-<summary>-plan.md` or `<YYYY-MM-DD>-<summary>-exec.md`
- `.test/` files use phase prefix: `<YYYY-MM-DD>-<phase>-criteria.md` (test plan) or `<YYYY-MM-DD>-<phase>-results.md` (test outcomes)
- `.summary.md` is a condensed context file â€” written by `plan`/`check`/`exec` after each run, read by subsequent steps instead of all history files. Prevents context window overflow as task accumulates history
- Each history directory (`.analysis/`, `.test/`, `.bugfix/`, `.notes/`) contains a `.summary.md` that condenses all entries in that directory. **Overwritten** (not appended) each time a new entry is added to the directory. The task-level `.summary.md` integrates from these directory summaries rather than reading every individual file
- Global directories (`.experiences/`, `.references/`) also contain a `.summary.md` index â€” skills read it first to find relevant files by keyword, avoiding full directory scans

### .summary.md Format

`.summary.md` is overwritten (not appended) on each write. Recommended structure:

```markdown
# Task Summary: <title>

**Status**: <status> | **Phase**: <phase> | **Progress**: <completed_steps>/<total_steps>

## Plan Overview
<!-- 3-5 sentence summary of the implementation approach -->

## Current State
<!-- What was last done, what's next -->

## Key Decisions
<!-- Important architectural/design decisions made so far -->

## Known Issues
<!-- Active issues, blockers, or risks -->

## Lessons Learned
<!-- Patterns, workarounds, or discoveries from execution -->
```

Writers should keep `.summary.md` under ~200 lines. It is a context window optimization â€” not a full record (that's `.report.md`).

### Global Directory .summary.md Format

`.experiences/.summary.md` and `.references/.summary.md` serve as keyword indexes for fast file discovery. Overwritten on each new entry. Recommended structure:

```markdown
# Experiences Index
<!-- or: # References Index -->

| File | Domain/Topic | Keywords | Updated |
|------|-------------|----------|---------|
| software.md | software | testing, API design, error handling | 2024-01-15 |
| dsp.md | dsp | FFT, audio filters, sample rate | 2024-01-20 |
```

Skills read this `.summary.md` first, match keywords against their current task requirements, then read only the matched `<topic>.md` files. This avoids reading all files in the directory.

Topic filenames in `.references/` use kebab-case: `[a-z0-9]+(-[a-z0-9]+)*` (e.g., `express-middleware.md`, `ffmpeg-filters.md`). No uppercase, no underscores, no dots (except the `.md` extension).

### .index.json Schema

```json
{
  "title": "Human-readable task title",
  "type": "",
  "status": "draft",
  "phase": "",
  "completed_steps": 0,
  "created": "2024-01-01T00:00:00Z",
  "updated": "2024-01-01T00:00:00Z",
  "depends_on": [],
  "tags": [],
  "branch": "task/module-name",
  "worktree": ".worktrees/task-module-name"
}
```

Notes: `worktree` is empty string `""` if not using worktree. `depends_on` entries can be simple strings (require `complete`) or objects `{ "module": "...", "min_status": "..." }`.

#### Type Field

The `type` field identifies the task's domain. It is **auto-discovered** by `research` during the first `plan` phase â€” `init` does not accept a `--type` argument. All subsequent sub-commands (`check`, `exec`) read this field to adapt their behavior.

**Type format**: Single type (`software`) or pipe-separated hybrid (`data-pipeline|ml`). Parsing: `type.split('|')` â†’ `[0]` is primary, `[1:]` are secondary domains.

**Seed types**: Predefined types are maintained in `init/references/seed-types.md` and used to initialize `AiTasks/.type-registry.md` on first `init`. The registry is auto-expanded by `research` when new domains are discovered. See `init/references/seed-types.md` for the full table (19 seed types including software, DSP, ML, science subtypes, chip-design, etc.).

Scientific research types follow [arXiv taxonomy](https://arxiv.org/category_taxonomy) â€” use `science:<domain>` for unlisted fields (e.g., `science:astro`, `science:neuro`, `science:materials`).

**Auto-discovery**: Type is determined automatically by `research` during the first `plan` phase (see `plan/references/type-profiling.md`). Research analyzes `.target.md` + web search to identify the domain, detects hybrid indicators, and writes the type to `.index.json`. No user input is needed â€” `init` creates tasks with `type: ""`, which `research` fills in.

**Auto-expanding registry**: `AiTasks/.type-registry.md` holds all known types (seed + dynamically discovered). When `research` identifies a domain not in the registry, it appends a new row automatically. The predefined table above is a **seed**, not a ceiling â€” new domains are registered on demand.

**Hybrid types**: Tasks spanning multiple domains use pipe-separated format (e.g., `data-pipeline|ml`). The first segment is primary (drives architecture), subsequent segments are secondary (add domain-specific verification and implementation concerns). All phases read experience files and apply methodology for **all** segments.

**Type profile**: Every task module gets a `.type-profile.md` during planning. This file is the **authoritative** domain methodology source for the task â€” all phases (verify, check, exec) read it first, before falling back to static reference tables. The profile is updated progressively as research/verify/check/exec discover new domain information.

**Type field validation**: Each pipe-separated segment must match `[a-zA-Z0-9_:-]+`. Full type field regex: `[a-zA-Z0-9_:|-]+`. `plan` MUST validate before writing to `.index.json`. `report` MUST validate before using as `.experiences/<type>.md` filename to prevent path traversal.

**Unknown type handling**: When `check` or `exec` encounters a `type` value not matching any known domain in the reference tables, it reads `.type-profile.md` for task-specific methodology. If `.type-profile.md` also doesn't exist (legacy task), it falls back to `software` methodology and records a warning in `.analysis/` (check) or `.notes/` (exec).

#### Phase Field

The `phase` field disambiguates sub-states within a status, primarily for `re-planning` auto recovery:

| Status | Phase | Meaning | Auto Entry Action |
|--------|-------|---------|-------------------|
| `re-planning` | `needs-plan` | check REPLAN set status, plan hasn't run yet | `plan --generate` |
| `re-planning` | `needs-check` | plan regenerated, ready for assessment | `verify` â†’ `check --checkpoint post-plan` |
| (other) | `""` (empty) | No sub-state needed | Status-based routing |

Writers: `check` sets `phase: needs-plan` on REPLAN and on NEEDS_REVISION when status is `re-planning`. `plan` sets `phase: needs-check` when completing on `re-planning` status. `annotate` sets `phase: needs-check` when the new status is `re-planning` (same rule as `plan`). All other transitions clear `phase` to `""`.

### Status State Machine

| Status | Description | Transitions To |
|--------|-------------|----------------|
| `draft` | Task target being defined | `planning`, `cancelled` |
| `planning` | Plan being researched | `review`, `blocked`, `cancelled` |
| `review` | Plan passed assessment | `executing`, `re-planning`, `cancelled` |
| `executing` | Implementation in progress | `complete`, `re-planning`, `blocked`, `cancelled` |
| `re-planning` | Plan being revised | `review`, `blocked`, `cancelled` |
| `complete` | Finished and verified | â€” (terminal) |
| `blocked` | Blocked by dependency/issue | `planning`, `cancelled` |
| `cancelled` | Abandoned (via `cancel`) | â€” (terminal) |

### Complete State Ã— Command Matrix

Every (state, sub-command) combination. `â†’X` = transitions to X. `=` = stays same. `âŠ˜` = rejected (prerequisite fail). `â€”` = no status change.

| State â†“ \ Command â†’ | plan | annotate | check post-plan | check mid-exec | check post-exec | exec | merge | report | cancel |
|---|---|---|---|---|---|---|---|---|---|
| `draft` | â†’`planning` | â†’`planning` | âŠ˜ | âŠ˜ | âŠ˜ | âŠ˜ | âŠ˜ | â€” | â†’`cancelled` |
| `planning` | =`planning` | =`planning` | PASSâ†’`review` / NEEDS_REVISION=`planning` / BLOCKEDâ†’`blocked` | âŠ˜ | âŠ˜ | âŠ˜ | âŠ˜ | â€” | â†’`cancelled` |
| `review` | â†’`re-planning` | â†’`re-planning` | âŠ˜ | âŠ˜ | âŠ˜ | â†’`executing` | âŠ˜ | â€” | â†’`cancelled` |
| `executing` | â†’`re-planning` | â†’`re-planning` | âŠ˜ | CONT=`executing` / NEEDS_FIX=`executing` / REPLANâ†’`re-planning` / BLOCKEDâ†’`blocked` | ACCEPT=`executing` (signalâ†’merge) / NEEDS_FIX=`executing` / REPLANâ†’`re-planning` | =`executing` (NEEDS_FIX fix) / â†’`blocked` (dependency) | â†’`complete` / =`executing` (conflict) | â€” | â†’`cancelled` |
| `re-planning` | =`re-planning` | =`re-planning` | PASSâ†’`review` / NEEDS_REVISION=`re-planning` / BLOCKEDâ†’`blocked` | âŠ˜ | âŠ˜ | âŠ˜ | âŠ˜ | â€” | â†’`cancelled` |
| `complete` | âŠ˜ | âŠ˜ | âŠ˜ | âŠ˜ | âŠ˜ | âŠ˜ | âŠ˜ | â€” (write) | âŠ˜ |
| `blocked` | â†’`planning` | â†’`planning` | âŠ˜ | âŠ˜ | âŠ˜ | âŠ˜ | âŠ˜ | â€” (write) | â†’`cancelled` |
| `cancelled` | âŠ˜ | âŠ˜ | âŠ˜ | âŠ˜ | âŠ˜ | âŠ˜ | âŠ˜ | â€” (write) | âŠ˜ |

**Legend:** `â†’X` transition, `=X` self-loop (stays same status), `âŠ˜` rejected, `â€”` no status change.

**Verification properties:**
- Every non-terminal state has â‰¥1 exit path (no deadlock)
- Terminal states: only `complete` and `cancelled`
- `cancel` is available on all non-terminal states (rejected on `complete` and `cancelled`)
- `exec` requires `review` gate (cannot skip `check`)
- `merge` requires ACCEPT verdict gate (cannot skip `check post-exec`)
- `re-planning` must pass through `check` to reach `review`
- NEEDS_FIX/NEEDS_REVISION self-loops are broken by auto signal routing (`next` field)

### Annotation Format (for `annotate` sub-command)

`.tmp-annotations.json` contains four `string[][]` arrays:

```json
{
  "Insert Annotations": [["Line{N}:...before20", "content", "after20..."]],
  "Delete Annotations": [["Line{N}:...before20", "selected", "after20..."]],
  "Replace Annotations": [["Line{N}:...before20", "selected", "replacement", "after20..."]],
  "Comment Annotations": [["Line{N}:...before20", "selected", "comment", "after20..."]]
}
```

| Type | Elements | Structure |
|------|----------|-----------|
| Insert | 3 | [context_before, content, context_after] |
| Delete | 3 | [context_before, selected_text, context_after] |
| Replace | 4 | [context_before, selected_text, replacement, context_after] |
| Comment | 4 | [context_before, selected_text, comment, context_after] |

Context: `context_before` = `"Line{N}:...{â‰¤20 chars}"`, newlines as `â†µ`. `context_after` = `"{â‰¤20 chars}..."`.

### depends_on Format

Supports two formats â€” simple string (require `complete`) and object (custom minimum status):

```json
{
  "depends_on": [
    "auth-refactor",
    { "module": "api-design", "min_status": "review" }
  ]
}
```

Simple string `"auth-refactor"` â†’ `AiTasks/auth-refactor`, requires status `complete`.

Extended object `{ "module", "min_status" }` â†’ requires the dependency to be at **or past** `min_status` in the state machine progression: `draft` < `planning` < `review` < `executing` < `complete`. Status `blocked`, `re-planning`, `cancelled` do not satisfy any `min_status`.

**Dependency enforcement**: `exec` and `merge` MUST validate that all `depends_on` modules meet their required status before proceeding. If any dependency is not met, the sub-command rejects with a clear error listing the blocking dependencies and their current statuses. `check` also flags unmet dependencies as a blocking issue.

### Git Integration

Every task module has a dedicated git branch. Worktrees are optional for parallel execution.

#### Branch Convention

| Item | Format | Example |
|------|--------|---------|
| Branch name | `task/<module-name>` | `task/auth-refactor` |
| Worktree path | `.worktrees/task-<module-name>` | `.worktrees/task-auth-refactor` |

#### Commit Message Convention

All ai-cli-task triggered commits use `--` prefix to distinguish from user manual commits:

```
-- ai-cli-task(<module>):<type> <description>
```

| type | Scenario | Commit Scope |
|------|----------|-------------|
| `init` | Task initialization | AiTasks/ directory files |
| `plan` | Plan generation | AiTasks/ directory files |
| `check` | Check evaluation results | AiTasks/ directory files |
| `research` | Reference collection | AiTasks/.references/ files |
| `verify` | Test execution and verification | AiTasks/ directory files |
| `annotate` | Annotation processing | AiTasks/ directory files |
| `summarize` | Context summary regeneration | AiTasks/ directory files |
| `exec` | Execution state changes | AiTasks/ directory files |
| `feat` | New feature code during exec | Project files |
| `fix` | Bugfix code during exec | Project files |
| `refactor` | Code cleanup before merge | Project files |
| `merge` | Merge to main + conflict resolution | â€” (merge commit) |
| `report` | Report generation | AiTasks/ directory files |
| `cancel` | Task cancellation | AiTasks/ directory files |

Examples:
```
-- ai-cli-task(auth-refactor):init initialize task module
-- ai-cli-task(auth-refactor):plan generate implementation plan
-- ai-cli-task(auth-refactor):research collect references
-- ai-cli-task(auth-refactor):check post-plan PASS â†’ review
-- ai-cli-task(auth-refactor):feat add user auth middleware
-- ai-cli-task(auth-refactor):fix fix token expiration check
-- ai-cli-task(auth-refactor):exec step 2/5 done
-- ai-cli-task(auth-refactor):check post-exec ACCEPT
-- ai-cli-task(auth-refactor):refactor cleanup before merge
-- ai-cli-task(auth-refactor):merge merge completed task
-- ai-cli-task(auth-refactor):merge resolve merge conflict
-- ai-cli-task(auth-refactor):merge task completed
-- ai-cli-task(auth-refactor):report generate completion report
-- ai-cli-task(auth-refactor):verify full verification
-- ai-cli-task(auth-refactor):annotate annotations processed
-- ai-cli-task(auth-refactor):summarize regenerate context summary
-- ai-cli-task(auth-refactor):cancel user cancelled
```

Commit scope: AiTasks/ directory files (state/plan) or project files (feat/fix).

#### Refactoring & Merge

After task completion confirmed (`check --checkpoint post-exec` ACCEPT), the `merge` sub-command handles the full merge lifecycle:

1. **Task-level refactoring** (on task branch, before merge)
2. **Merge to main** (with conflict resolution â€” up to 3 attempts with verification)
3. **Cleanup** (worktree removal, branch deletion)

See `skills/merge/SKILL.md` for detailed merge strategy and conflict resolution flow.

**Recommended:** After all related tasks merge to main, do a project-level refactoring pass on main (cross-task cleanup, shared utilities, API consistency). This is a manual activity, not part of auto mode.

#### Worktree Parallel Execution

Without `--worktree`: all work happens on the task branch in the main worktree. Only one task can execute at a time (branch switching required).

With `--worktree` (passed to `init`):
```bash
git worktree add .worktrees/task-<module> -b task/<module>
```

- Each task runs in an isolated directory with full project copy
- Multiple tasks can `exec` simultaneously without conflict
- `auto` daemon operates in the task's worktree directory
- On completion, merge back: `git merge task/<module>` from main branch

#### Rollback

To revert a task to a previous checkpoint:
```bash
git log --oneline task/<module>    # find checkpoint commit
git reset --hard <commit>          # in the task's worktree
```

**Warning**: `git reset --hard` is irreversible â€” all uncommitted changes are lost. Only use in the task's dedicated worktree, never in the main worktree (which may contain other work). Consider `git stash` first if unsure.

#### .auto-signal Convention

Every sub-command that participates in the automation loop (plan, check, exec, merge, report, research, verify, annotate) MUST write `.auto-signal` on completion, regardless of whether auto mode is active. Utility sub-commands (list, summarize) do NOT write `.auto-signal`:

```json
{
  "step": "<sub-command>",
  "result": "<outcome>",
  "next": "<next sub-command or (stop)>",
  "checkpoint": "<checkpoint hint for next command, optional>",
  "timestamp": "<ISO 8601>"
}
```

- The `next` field follows the signal routing table documented in the `auto` sub-command.
- The `checkpoint` field provides context for the next command (e.g., `"post-plan"`, `"mid-exec"`, `"post-exec"`) when the `next` command needs it. Optional â€” omit when not applicable. If auto mode is not active, the file is harmless (gitignored, ephemeral). This fire-and-forget pattern avoids each skill needing to detect auto mode.
- **Atomic write**: `.auto-signal` MUST be written atomically â€” write to `.auto-signal.tmp` first, then `rename` to `.auto-signal`. POSIX `rename` is atomic, preventing the daemon from reading partially written JSON.

**Worktree note**: In worktree mode, `.auto-signal` MUST be written to the **main worktree's** `AiTasks/<module>/` directory (not the task worktree copy) to survive worktree removal during merge cleanup.

#### .gitignore

Add to project `.gitignore`:
```
.worktrees/
AiTasks/**/.tmp-annotations.json
AiTasks/**/.auto-signal
AiTasks/**/.auto-signal.tmp
AiTasks/**/.auto-stop
AiTasks/**/.lock
AiTasks/.experiences/.lock
AiTasks/.references/.lock
```

---

## Input Validation

All sub-commands that accept `<task_module>` MUST validate the path before processing:

| Check | Rule | Example |
|-------|------|---------|
| **Path containment** | Resolved path must be under `AiTasks/` directory (no `..` traversal) | `AiTasks/../etc/passwd` â†’ REJECT |
| **Module name** | Must match `[a-zA-Z0-9_-]+` (ASCII letters/digits/hyphens/underscores only) | `auth-refactor` âœ“, `../../foo` âœ— |
| **No symlinks** | Task module directory must not be a symlink (prevent symlink-based escape) | REJECT if `lstat` â‰  `stat` |
| **Existence** | Directory must exist (except for `init` which creates it) | REJECT if missing |

Validation is performed by resolving the absolute path and confirming it starts with the project's `AiTasks/` prefix. This prevents path traversal attacks where a crafted module name could read/write files outside the task directory.

### Concurrency Protection

Without worktree mode, only one task should be actively operated at a time. Sub-commands that modify state (`plan`, `exec`, `check`, `merge`) MUST check for an active lockfile (`AiTasks/<module>/.lock`) before proceeding:

1. **Acquire**: Attempt to create `AiTasks/<module>/.lock` with `O_CREAT | O_EXCL` (atomic create-if-not-exists). Write `{ session, pid, timestamp }` to identify the holder
2. **If lock exists**: Read lock content, check if holding process is still alive (kill -0). If dead â†’ remove stale lock and retry. If alive â†’ REJECT with error identifying the holding session
3. **Release**: Delete `.lock` on sub-command completion (including error paths)
4. **Worktree mode**: Lock not required â€” each worktree has its own copy of AiTasks/ files
5. **Stale lock recovery**: Use rename-based recovery instead of delete+create. When detecting a stale lock (holder dead): `rename` the stale `.lock` to `.lock.stale.<pid>`, then acquire normally with `O_CREAT | O_EXCL`. If the rename fails (another process already recovered), retry from step 1. Clean up `.lock.stale.*` files after successful acquisition

### .experiences/ Write Protection

`AiTasks/.experiences/<type>.md` is a shared resource across tasks. When `report` writes to it (experience distillation), it MUST acquire `AiTasks/.experiences/.lock` using the same lock protocol above. This prevents concurrent task completions from corrupting the experience file. For hybrid types (`A|B`), `report` writes to experience files for **all** pipe-separated segments (e.g., both `A.md` and `B.md`).

### .references/ Write Protection

`AiTasks/.references/<topic>.md` is a shared resource across tasks. The `research` sub-command is the primary writer (invoked by `plan` or standalone). When any sub-command (`research`, `exec`) writes to `.references/`, it MUST acquire `AiTasks/.references/.lock` using the same lock protocol above. This prevents concurrent tasks from corrupting the reference files.

### .index.json Corruption Recovery

If `.index.json` fails to parse (malformed JSON), sub-commands MUST attempt recovery before failing:

1. **Git recovery**: `git show HEAD:AiTasks/<module>/.index.json` â€” restore from latest committed version
2. **If git recovery fails**: Reconstruct minimal `.index.json` with `"status": "draft"`, `"phase": ""`, preserve only what's parseable
3. **Log**: Record corruption event and recovery action in `.analysis/<date>-index-recovery.md`

### Lifecycle Hooks (Extension Point)

Status transitions can optionally trigger external notifications. If `AiTasks/.hooks.md` exists, sub-commands read it for hook configuration:

```markdown
# Lifecycle Hooks

## on_complete
<!-- Shell command or URL to call when any task reaches `complete` -->
<!-- e.g., curl -X POST https://slack.webhook/... -d '{"text":"Task ${MODULE} completed"}' -->

## on_blocked
<!-- Notification when a task becomes blocked -->
```

Hooks are **best-effort** â€” failures are logged but do not block the status transition. This is an optional extension; the system works without `AiTasks/.hooks.md`.

---

## Sub-commands

> Each sub-command's core logic is in `skills/<name>/SKILL.md`. Reference material is in `skills/<name>/references/` and loaded on demand.

### Skill File Structure

```
skills/<name>/
â”œâ”€â”€ SKILL.md                # Core logic: steps, state transitions, signals, git
â””â”€â”€ references/             # On-demand reference material (loaded when needed)
    â”œâ”€â”€ task-type-*.md      # Domain-specific guidelines (plan/check/exec)
    â”œâ”€â”€ annotation-*.md     # Annotation processing details (plan)
    â””â”€â”€ *.md                # Other reference docs
```

**Main SKILL.md** contains the workflow: prerequisites, execution steps, state transitions, git conventions, `.auto-signal` definitions, and notes. It should be self-sufficient for understanding the sub-command's behavior.

**references/** contains large reference tables and domain-specific details that are only needed in specific situations. The main SKILL.md references these files with `See references/<file>.md` directives â€” Claude reads them on demand when the context requires it.

### init

`/ai-cli-task:init <module_name> [--title "..."] [--tags t1,t2] [--worktree]`

Create task module directory + `.index.json` (status `draft`, type empty) + `.target.md` template. Create git branch `task/<module_name>`, checkout to it (or create worktree with `--worktree`). Type is auto-discovered by `research` during planning. Module name: ASCII letters/digits/hyphens/underscores (`[a-zA-Z0-9_-]+`).

### plan

```
/ai-cli-task:plan <task_module> --generate
```

Research codebase + `.target.md` â†’ write implementation plan to `.plan.md` â†’ status `planning`. Annotation processing is handled by the `annotate` sub-command.

### research

`/ai-cli-task:research <task_module> [--scope full|gap]`

Collect and organize external domain knowledge into `AiTasks/.references/`. Acts as the intelligence arm of the task lifecycle â€” separating research from planning for clearer logic. Two scopes: `full` (comprehensive, first plan) and `gap` (incremental, re-plan). Status-neutral â€” does not change task status. Invoked by `plan` automatically (first plan â†’ `--scope full`, re-plan â†’ `--scope gap` conditional), or standalone for preparatory/supplementary research.

### check

`/ai-cli-task:check <task_module> [--checkpoint post-plan|mid-exec|post-exec]`

Decision maker at three lifecycle checkpoints:

| Checkpoint | Prerequisite | Outcomes |
|------------|-------------|----------|
| **post-plan** | `planning` / `re-planning` | PASSâ†’`review`, NEEDS_REVISION (no change), BLOCKEDâ†’`blocked` |
| **mid-exec** | `executing` | CONTINUE (no change), NEEDS_FIX (no change), REPLANâ†’`re-planning`, BLOCKEDâ†’`blocked` |
| **post-exec** | `executing` | ACCEPT (no change, signalâ†’`merge`), NEEDS_FIX (no change), REPLANâ†’`re-planning` |

ACCEPT signals â†’ `merge` sub-command for refactoring + merge. Tests MUST pass for ACCEPT.

### verify

`/ai-cli-task:verify <task_module> [--checkpoint quick|full|step-N]`

Run domain-adapted tests and verification procedures, producing structured result files in `.test/`. Does not render verdicts â€” that is `check`'s responsibility. Three checkpoint scopes: `quick` (build + lint + type check), `full` (all criteria + acceptance + regression), `step-N` (criteria for step N only). Status-neutral â€” does not change task status. Can be invoked standalone or internally by `check`/`exec`.

### exec

`/ai-cli-task:exec <task_module> [--step N]`

Execute implementation plan step-by-step. Prerequisite: status `review` or `executing` (NEEDS_FIX continuation). Reads `.plan.md` + `.analysis/` + `.test/`, implements changes, verifies per step against `.test/` criteria. On significant issues â†’ signal `(mid-exec)` for mid-exec evaluation. On all steps complete â†’ signal `(done)` for post-exec verification. Project file commits use `feat`/`fix` type.

### merge

`/ai-cli-task:merge <task_module>`

Merge completed task branch to main with automated conflict resolution. Prerequisite: status `executing` with ACCEPT verdict. Performs pre-merge refactoring, attempts merge (up to 3 conflict resolution retries with build/test verification), post-merge cleanup (worktree + branch). On persistent conflict â†’ stays `executing` (retryable after manual resolution).

### report

`/ai-cli-task:report <task_module> [--format full|summary]`

Generate `.report.md` from all task artifacts. Informational only â€” no status change. For `complete` tasks, includes change history via commit message pattern matching (works after branch deletion). Full format: Summary, Objective, Plan, Changes, Verification, Issues, Dependencies, Lessons.

### auto

`/ai-cli-task:auto <task_module> [--start|--stop|--status]`

Single-session autonomous loop: plan â†’ verify â†’ check â†’ exec â†’ verify â†’ check(mid) â†’ exec â†’ verify â†’ check(post) â†’ merge â†’ report, with self-correction. A single Claude session internally orchestrates all steps; the backend daemon monitors progress via `fs.watch` on `.auto-signal` and enforces safety limits.

**Status-based first entry:**

| Status | First Action |
|--------|-------------|
| `draft` | Validate `.target.md` has content â†’ plan --generate (stop if empty) |
| `planning` | verify â†’ check --checkpoint post-plan |
| `re-planning` | Read `phase`: `needs-plan` â†’ plan --generate; `needs-check` â†’ verify â†’ check --checkpoint post-plan; empty â†’ plan --generate (safe default) |
| `review` | exec |
| `executing` | verify â†’ check --checkpoint post-exec |
| `complete` | report â†’ stop |
| `blocked` / `cancelled` | stop |

**Signal-based subsequent routing** (`next` field breaks self-loops):

| step | result | next | checkpoint |
|------|--------|------|------------|
| check | PASS | exec | â€” |
| check | NEEDS_REVISION | plan | â€” |
| check | CONTINUE | exec | â€” |
| check | ACCEPT | merge | â€” |
| check | NEEDS_FIX | exec | mid-exec / post-exec |
| check | REPLAN / BLOCKED | plan / (stop) | â€” |
| plan | (any) | verify | post-plan |
| exec | (done) | verify | post-exec |
| exec | (mid-exec) | verify | mid-exec |
| exec | (step-N) | verify | mid-exec | â† manual `--step N` only |
| exec | (blocked) | (stop) | â€” |
| research | (collected)/(sufficient) | `<caller>` (plan/verify/check/exec) | post-research |
| verify | (pass/fail/partial) | check | â€” |
| annotate | (processed) | verify | post-plan |
| merge | success | report | â€” |
| merge | conflict | (stop) | â€” |
| report | (any) | (stop) | â€” |

**Safety**: max iterations (default 20), timeout (default 30 min), stop on `blocked`, one auto per session (SQLite PK), one auto per task (UNIQUE).

### cancel

`/ai-cli-task:cancel <task_module> [--reason "..."] [--cleanup]`

Cancel any non-terminal task â†’ `cancelled`. Rejected on `complete`/`cancelled`. Stops auto if running. Snapshots uncommitted changes before cancelling. With `--cleanup`, removes worktree + deletes branch. Without `--cleanup`, branch preserved for reference.

### list

```
/ai-cli-task:list [<task_module>] [--deps] [--timeline]
```

Read-only task query. Without arguments: summary table of all tasks. With `<task_module>`: single task details. With `--deps`: Mermaid dependency graph. With `--timeline <module>`: status transition timeline from git history. Pure read-only â€” no files written, no status changes, no git commits, no `.auto-signal`.

### annotate

```
/ai-cli-task:annotate <task_file_path> <annotation_file_path> [--silent]
```

Process `.tmp-annotations.json` from the Plan panel (Insert/Delete/Replace/Comment) with cross-impact assessment (None/Low/Medium/High) â†’ update task file â†’ delete annotation file. Comments add `> ğŸ’¬`/`> ğŸ“` blockquotes, never modify existing content. REJECT on `complete`/`cancelled`. State transitions mirror `plan`: `draft`â†’`planning`, `review`/`executing`â†’`re-planning`, `blocked`â†’`planning`.

### summarize

`/ai-cli-task:summarize <task_module> [--all]`

Regenerate `.summary.md` for context recovery or refresh. Reads all task artifacts (`.index.json`, `.target.md`, `.plan.md`, `.analysis/`, `.bugfix/`, `.test/`, `.notes/`) and produces a condensed summary. With `--all`, also regenerates each sub-directory's `.summary.md`. Status-neutral â€” does not change task status. No `.auto-signal` (maintenance tool, not part of auto loop).
